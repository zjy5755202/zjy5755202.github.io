<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="计算机网络复习总结第一章 计算机网络和因特网因特网组成主机：各种各样的设备，包括计算机，移动手机，服务器等等 通信链路：传输数据的媒介，包含同轴电缆、铜线、光纤和无线电频谱 交换机：有路由器和链路层交换机两种 一种类比：想象用于传送分组的分组交换网络可以类比为承载运输车辆的运输网络，网络包含了高速公路、公路和交叉口。一个工厂需要将大量的货物搬运到数千公里以外的目的地仓库。在工厂中，货物要分开并且装">
<meta property="og:type" content="article">
<meta property="og:title" content="zhuzhu&#39;s web">
<meta property="og:url" content="http://yoursite.com/2019/05/26/计算机网络复习总结/index.html">
<meta property="og:site_name" content="zhuzhu&#39;s web">
<meta property="og:description" content="计算机网络复习总结第一章 计算机网络和因特网因特网组成主机：各种各样的设备，包括计算机，移动手机，服务器等等 通信链路：传输数据的媒介，包含同轴电缆、铜线、光纤和无线电频谱 交换机：有路由器和链路层交换机两种 一种类比：想象用于传送分组的分组交换网络可以类比为承载运输车辆的运输网络，网络包含了高速公路、公路和交叉口。一个工厂需要将大量的货物搬运到数千公里以外的目的地仓库。在工厂中，货物要分开并且装">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559531655388.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559531666667.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537525038.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537284659.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537308392.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537339396.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559538872926.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559539235987.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559539763141.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559542770915.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559542827240.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559564304860.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559565068865.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559566619787.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559283554460.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559570362396.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559570258660.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559289045652.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573222448.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573364577.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573408086.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573494833.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573553642.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573571173.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573595996.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573612593.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573644090.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573656642.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616030731.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616044080.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616523633.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616582889.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616674323.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616593718.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616702009.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616866643.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617619691.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617566071.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617659417.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617677948.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617741490.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559613248514.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559613509468.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559629284091.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559629300456.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559629307513.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630881617.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630886302.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630937911.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630941591.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630949197.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630955296.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559732109367.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633361684.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633388589.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633393341.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633408224.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633418278.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633652962.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634680014.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634928167.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634934408.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634962368.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559635101748.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559635116676.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559649835665.png">
<meta property="og:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559651243274.png">
<meta property="og:updated_time" content="2019-06-08T06:49:38.519Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuzhu&#39;s web">
<meta name="twitter:description" content="计算机网络复习总结第一章 计算机网络和因特网因特网组成主机：各种各样的设备，包括计算机，移动手机，服务器等等 通信链路：传输数据的媒介，包含同轴电缆、铜线、光纤和无线电频谱 交换机：有路由器和链路层交换机两种 一种类比：想象用于传送分组的分组交换网络可以类比为承载运输车辆的运输网络，网络包含了高速公路、公路和交叉口。一个工厂需要将大量的货物搬运到数千公里以外的目的地仓库。在工厂中，货物要分开并且装">
<meta name="twitter:image" content="c:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559531655388.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/26/计算机网络复习总结/">





  <title> | zhuzhu's web</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zhuzhu's web</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">这是zhuzhu的个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/计算机网络复习总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhuzhu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhuzhu's web">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-26T17:04:12+08:00">
                2019-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="计算机网络复习总结"><a href="#计算机网络复习总结" class="headerlink" title="计算机网络复习总结"></a>计算机网络复习总结</h1><h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>主机：各种各样的设备，包括计算机，移动手机，服务器等等</p>
<p>通信链路：传输数据的媒介，包含同轴电缆、铜线、光纤和无线电频谱</p>
<p>交换机：有<strong>路由器</strong>和<strong>链路层</strong>交换机两种</p>
<p>一种类比：想象用于传送分组的分组交换网络可以类比为承载运输车辆的运输网络，网络包含了高速公路、公路和交叉口。一个工厂需要将大量的货物搬运到数千公里以外的目的地仓库。在工厂中，货物要分开并且装上卡车车队。然后每辆卡车独立的通过高速公路、公路和立交桥组成的网络向仓库运货物。在目的地仓库，卸下这些货物，并且和一同装载的同一批货物的其余部分对方在一起。因此，许多方面来说，<strong>分组</strong>类似于<strong>卡车</strong>，<strong>通信链路</strong>类似于<strong>高速公路和公路</strong>，<strong>分组交换机</strong>类似<strong>于交叉口</strong>，而<strong>端系统</strong>就类似于<strong>仓库</strong>。就像卡车选取运输货物的一条路线前行一样，分组则选取计算机网络的一条路径前行。</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>通常把与因特网相连的计算机和其他设备称为<strong>端系统（主机）</strong>。</p>
<p>端系统通过<strong>物理连接</strong>到<strong>边缘路由器（第一台路由器）</strong>接入互联网。</p>
<p>家庭接入：DSL（数字用户线）、电缆、FTTH（光纤入户）</p>
<p>企业接入：以太网和WIFI</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心即互联因特网端系统的<strong>分组交换机和链路</strong>构成的<strong>网状网路</strong>。</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>网络应用当中，<strong>端系统之间</strong>彼此交换<strong>报文</strong>。</p>
<p>源会将长报文划分成为较小的数据块，称之为分组。在源和目的地之间，每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>传送。分组以等于该链路最大传输速率传输通过通信链路。</p>
<h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><p>多数分组交换机在链路的接入端使用存储转发存储机制。存储转发传输是指能够开始向输出链路传输该分组的第一个比特前，必须接受到整个分组。</p>
<p>一般情况：通过由N条速率均为R的链路组成的路径，从源到目的地发送一个分组，我们看到的端到端时延是：<br>$$<br>d=NL/R<br>$$</p>
<h4 id="排队时延和分组丢失"><a href="#排队时延和分组丢失" class="headerlink" title="排队时延和分组丢失"></a>排队时延和分组丢失</h4><p>每台分组交换机有多条链路与之相连。对于<strong>每条相连的链路</strong>，该分组交换机具有一个<strong>输出缓存</strong>（也称为输出队列） 它用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的<strong>排队时延</strong>。这些时延是变化的，变化的程度取决于网络的拥塞程度。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。这种情况下，将出现<strong>分组丢失（丢包）</strong>现象，到达的分组或已经排队的分组之一将被丢弃。</p>
<h4 id="转发表和路由协议"><a href="#转发表和路由协议" class="headerlink" title="转发表和路由协议"></a>转发表和路由协议</h4><p>路由器从与它相连的一条通信链路得到分组，然后向与他相连的另一条通信链路转发该分组。</p>
<p>分组的首部都会含有源和目的地的IP地址，路由器就是通过检查目的地址的一部分，然后把<strong>目的地址</strong>映射成<strong>输出链路</strong>然后转发到对应的输出链路当中。</p>
<p>因特网具有一些特殊的路由选择协议用于自动地设置这些转发表。</p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>电路交换网络当中，在端系统通信会话期间预留了系统间沿路径通信所需要的资源。</p>
<p>可以把分组交换比作是<strong>不需要预定的餐馆</strong>，而电路交换是<strong>需要预定的餐馆</strong>。</p>
<p>对于需要预订的餐馆，我们在离开家之前必须承受先打电话预定的麻烦，但当我们到达餐馆的时候，原则上我们能够立即入座并点菜。对于不需要预订的参观，我们不必麻烦地预订餐馆，但当我们到达该餐馆时候，也许不得不等待一张餐桌空闲之后再入座。</p>
<p>在发送方能够发送消息前，网络必须在通信双方之间建立一个连接，这个链接被称为<strong>电路</strong>。这个链接的状态会被沿着发送方和接收方之间路径上的交换机维护。</p>
<h4 id="电路交换网络中的复用"><a href="#电路交换网络中的复用" class="headerlink" title="电路交换网络中的复用"></a>电路交换网络中的复用</h4><ul>
<li>时分复用（TDM）  传输速率=帧速率✖一个时隙中的比特数</li>
<li>频分复用（FDM）</li>
</ul>
<p>缺点：静默期专用电路空闲浪费资源。</p>
<h4 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h4><p>分组交换缺点：不适合实时服务，端到端的时延是不可预测的。</p>
<p>分组交换优点：提供更好的带宽共享，更简单、更有效、实现成本更低。按需分配链路</p>
<h4 id="网络中的网络"><a href="#网络中的网络" class="headerlink" title="网络中的网络"></a>网络中的网络</h4><ul>
<li>网络结构1： 单一的全球传输ISP互联所有的接入ISP</li>
<li>网络结构2：数十万个接入ISP和多个全球传输ISP</li>
<li>网络结构3：多层级结构，区域ISP-&gt;较大的区域ISP-&gt;第一层ISP</li>
<li>网络结构4：<ul>
<li>POP(存在点)：？</li>
<li>多宿：上层接多个ISP</li>
<li>对等：同级直连，互不收费</li>
</ul>
</li>
<li>网络结构5：<ul>
<li>内容提供商，直连顶层ISP，与底层ISP对等</li>
</ul>
</li>
</ul>
<h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>当分组沿一个节点沿着这条路径到后继节点，该分组在沿途中的每个节点经受了几种不同类型的时延。这些时延最重要的是<strong>节点处理时延、排队时延、传输时延和传播时延</strong>。这些时延总体累加起来是<strong>节点总时延</strong>。</p>
<ul>
<li>处理时延：检查分组首部和决定分组对应的输出链路。检查比特级的差错等等所耗用的时间。</li>
<li>排队时延：分组在链路上等待传输的时间。</li>
<li>传输时延：将所有分组的比特推向链路所需要的时间。</li>
<li>传播时延：从链路起点到下一个站点传播所需要的时间</li>
</ul>
<p>$$<br>d<del>nodal=d</del>proc+d<del>queue+d</del>trans+d~prop<br>$$</p>
<p>R-传输速率  a-分组的到达速率 L-分组的大小</p>
<h3 id="流量强度"><a href="#流量强度" class="headerlink" title="流量强度"></a>流量强度</h3><p>$$<br>La/R<br>$$</p>
<p>设计系统时流量强度不能大于1</p>
<p>随着流量强度接近于1，平均排队时延迅速增加。该强度的少量增加将导致时延大比例增加。</p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>瞬时吞吐量是主机接受到文件的速率。</p>
<p>平均吞吐量 F-文件大小   T-接受耗时<br>$$<br>F/T<br>$$</p>
<p><strong>比特</strong>想象为<strong>流体</strong>，<strong>通信链路</strong>想象为<strong>管道</strong></p>
<p>今天互联网中对吞吐量的限制因素通常是接入网。</p>
<p>如果共享链路的话，瓶颈就不再与接入网了，而是在于核心中的共享链路。</p>
<h2 id="协议分层及其服务模型"><a href="#协议分层及其服务模型" class="headerlink" title="协议分层及其服务模型"></a>协议分层及其服务模型</h2><h3 id="五层协议栈"><a href="#五层协议栈" class="headerlink" title="五层协议栈"></a>五层协议栈</h3><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559531655388.png" alt="1559531655388"></p>
<ul>
<li>应用层：应用层是网络应用程序及他们的应用层协议存留的地方。应用层协议分布在多个端系统上，而<strong>一个端系统中的应用程序</strong>使用协议与<strong>另一个端系统中的应用程序</strong>交换信息分组。我们把这种位于应用层的信息分组称为<strong>报文</strong>。</li>
<li>运输层：运输层在应用程序端点之间传输应用层报文。因特网有两种运输层协议：TCP和UDP。<strong>运输层分组</strong>称为<strong>报文段</strong>。</li>
<li>网络层 ：因特网的网络层负责将称为数据报的网络层分组从一台主机移动到另一台主机。网络层包含了IP网络协议，还有很多路由选择协议。</li>
<li>链路层 ：网络层通过源和目的地之间的一系列路由器路由数据报。在每个节点，网络层将数据报下传给链路层，链路层沿着路经将数据报传递给下一个节点，在下一个节点，链路层将数据报上传给网络层。<strong>链路层分组</strong>称为<strong>帧</strong>。</li>
<li>物理层：链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素。物理层的任务是将该帧中的一个个<strong>比特</strong>从<strong>一个节点</strong>移动到<strong>下一个节点</strong>。</li>
</ul>
<h3 id="OSI七层协议栈"><a href="#OSI七层协议栈" class="headerlink" title="OSI七层协议栈"></a>OSI七层协议栈</h3><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559531666667.png" alt="1559531666667"></p>
<ul>
<li>表示层：使通信的应用程序能够解释交换数据的含义。这些服务包含数据压缩和数据加密以及数据描述。</li>
<li>会话层：提供了数据交换的定界和同步功能，包含了建立检查点和回复方案的方法。</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>数据从发送端的协议栈从上到下，沿着中间的链路层交换机和路由器的协议栈上上下下，然后向上到达接收端系统的协议栈。</p>
<p>在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段。有效载荷字段通常是来自上一层的分组。</p>
<h2 id="面向攻击的网络"><a href="#面向攻击的网络" class="headerlink" title="面向攻击的网络"></a>面向攻击的网络</h2><ul>
<li>注入有害程序</li>
<li>攻击服务器和网络基础设施</li>
<li>嗅探分组</li>
<li>伪装成信任的人</li>
</ul>
<h1 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h1><h2 id="应用程序体系结构"><a href="#应用程序体系结构" class="headerlink" title="应用程序体系结构"></a>应用程序体系结构</h2><ul>
<li><p>客户-服务器体系结构</p>
<ul>
<li>有一个总是打开的主机成为服务器，它服务于来自许多其他成为客户的主机的请求。该服务器具有固定的、周知的地址。客户之间互相不通信。具有这样的体系结构的非常著名的应用程序包含Web、FTP、Telnet和电子邮件。</li>
</ul>
</li>
<li><p>对等体系结构（P2P）</p>
<ul>
<li>位于数据中心的专用服务器有最小依赖。相反，应用程序在简短链接的主机对之间使用直接通信，这些主机成为对等方。</li>
</ul>
</li>
</ul>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>程序</p>
<p>进程</p>
<p>本书的关注点在于<strong>不同端系统</strong>上的<strong>进程间</strong>的通信。</p>
<p>两个不同端系统上的进程，通过跨越计算机网络<strong>交换报文</strong>互相通信。</p>
<h3 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h3><p>网络应用程序有成对的进程组成，这些进程之间互相发送报文。</p>
<p>在一对进程之间的通信会话场景中，<strong>发起通信</strong>的进程被标识为<strong>客户</strong>，在会话开始时<strong>等待联系</strong>的进程是<strong>服务器</strong></p>
<h3 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h3><p>从一个进程向另一个进程发送的报文必须经过下面的网络/进程通过一个称为套接字的软件接口像网络发送报文和从网络接受报文。</p>
<p>一个类比：我们可以想象把<strong>进程</strong>类比为一栋<strong>建筑</strong>，而<strong>套接字</strong>就是<strong>这栋建筑的房间的门</strong>。当一个进程想向另外一个进程<strong>发送报文</strong>的时候，他把<strong>报文推出该房间</strong>，然后通过<strong>运输线路</strong>运输到<strong>另外一栋建筑的某一个房间门口(某一个进程的套接字)</strong>，然后通过<strong>房门（对应的套接字）</strong>进入到该<strong>房间（进程）</strong>进行相应的处理。</p>
<p><strong>套接字</strong>是同一台主机内<strong>应用层</strong>和<strong>运输层</strong>之间的<strong>接口</strong>。</p>
<h3 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h3><p>在一台主机上运行的进程为了向在另外一台主机上运行的进程发送报文需要有一个目的地地址。</p>
<p>这个目的地地址包含了两个信息</p>
<ul>
<li>IP地址——标识主机</li>
<li>端口号——标识进程</li>
</ul>
<p>应用层定义了</p>
<ul>
<li>交换的报文类型</li>
<li>各种报文类型的语法</li>
<li>字段的语义</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="工作原理简介"><a href="#工作原理简介" class="headerlink" title="工作原理简介"></a>工作原理简介</h3><p>当用户请求一个Web页面时，浏览器向服务器发出对该页面中所包含对象的HTTP请求报文，服务器接收到请求并用包含这些对象的HTTP响应报文进行响应。HTTP底层是使用TCP运输协议的。</p>
<p>同时HTTP是一个无状态协议，不会存储任何关于客户的状态信息。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537525038.png" alt="1559537525038"></p>
<h3 id="非持续链接和持续链接"><a href="#非持续链接和持续链接" class="headerlink" title="非持续链接和持续链接"></a>非持续链接和持续链接</h3><ul>
<li>非持续链接：每个请求/响应对是经一个<strong>单独</strong>的TCP连接发送</li>
<li>持续链接：所有的请求和响应经<strong>相同</strong>的TCP连接发送</li>
</ul>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><h4 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h4><p>​                  <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537284659.png" alt="1559537284659">                                </p>
<p>   　</p>
<p>简单来说请求报文就是由请求行、请求头、内容实体组成的，注意，每一行的末尾都有回车和换行，在内容实体和请求头之间另有一个空行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是键值对的形式存在的，就是字段名：值；内容实体就是要传输的数据。</p>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>   <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537308392.png" alt="1559537308392"></p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><h4 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559537339396.png" alt="1559537339396"></p>
<p>简单来说响应报文由状态行、响应首部字段（响应头）、响应实体组成，其中第一行是状态行，依次包含HTTP版本，状态码和状态短语组成；在一个回车换行之后是响应头，也是键值对的形式，字段名：值；然后会有一个空行也包含回车换行，之后是响应实体，就是要传输的数据。在上面的例子当中就是一个非常简单的HTML页面。</p>
<h4 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559538872926.png" alt="1559538872926"></p>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li>200 OK:请求成功</li>
<li>301 Moved Permanently：重定向</li>
<li>400 Bad request：服务器不能理解该请求</li>
<li>404 Not Found：请求的资源不在</li>
<li>505 HTTP Version Not Supported：服务器不支持请求的HTTP版本</li>
</ul>
<h3 id="用户和服务器的交互：Cookie"><a href="#用户和服务器的交互：Cookie" class="headerlink" title="用户和服务器的交互：Cookie"></a>用户和服务器的交互：Cookie</h3><h4 id="支撑原理"><a href="#支撑原理" class="headerlink" title="支撑原理"></a>支撑原理</h4><ul>
<li>HTTP响应报文中有一个cookie首部行</li>
<li>HTTP请求报文中有一个cookie首部行</li>
<li>用户端系统中有一个cookie文件由用户的浏览器进行处理</li>
<li>Web站点服务器有一个后端数据库</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>Susan首次和Amazon.com联系，当请求报文到达该Amazon服务器时，Web站点将产生一个唯一识别码，并以此作为索引在他的后端数据库中产生一个表项。然后在他的响应报文中，由Set-cookie这么一个首部行，然后Susan浏览器收到这个响应报文的时候，就会最特定cookie文件当中添加这么一行数据;服务器主机名 识别码。然后以后在Susan访问该网站的时候，浏览器就会到cookie文件中取得这个标识码放入请求报文首部行里面带过去给服务器，服务器就能够在后端查询和该用户相关的一些信息了。从而实现用户和服务器的交互。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559539235987.png" alt="1559539235987"></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Web缓存器既是客户又是服务器，通常由ISP购买并配置。</p>
<h4 id="工作机理"><a href="#工作机理" class="headerlink" title="工作机理"></a>工作机理</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559539763141.png" alt="1559539763141"></p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul>
<li>大大降低对客户请求的响应时间</li>
<li>大大减少一个机构的接入链路到因特网的通信量</li>
</ul>
<h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>出现契机：尽管高速缓存能偶减少用户感受到的响应时间，但是有时候缓存里面存储的内容并不是最新的内容，所以HTTP提供了一种机制，允许缓存器证实它所存储的对象是最新的。</p>
<p>如果请求报文当中</p>
<ul>
<li>使用了GET方法</li>
<li>含有If-Modified-Since首部行</li>
</ul>
<p>这个报文就是一个条件Get报文。</p>
<p>缓存器向服务器发送一个报文检查请求的报文有没有更新过</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559542770915.png" alt="1559542770915"></p>
<p>Web服务器对这个报文进行响应说明没有更新，也没有附带对象，节省了带宽。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559542827240.png" alt="1559542827240"></p>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul>
<li>用户代理</li>
<li>邮件服务器</li>
<li>简单邮件传输协议（SMTP）</li>
</ul>
<p>每个接收方在其中的某个邮件服务器上面有一个邮箱，邮箱管理和维护者发送给该用户的报文。</p>
<h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>SMTP是因特网电子邮件中主要的应用层协议。他使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。和大多数的应用协议一样，SMTP也有两个部分：运行在发送方邮件服务器的客户端和运行在接收方邮件服务器的服务器端。一般来说，在一个邮件服务器上面两者都运行，负责发送服务器内邮箱发出的邮件和接收发往服务器中的邮箱的邮件。</p>
<h3 id="SMTP基本操作示例"><a href="#SMTP基本操作示例" class="headerlink" title="SMTP基本操作示例"></a>SMTP基本操作示例</h3><p>Alicex想给Bob发送一封简单的ASCⅡ报文</p>
<p>1）Alice调用他的邮件代理程序并提供Bob的邮箱地址，撰写报文，然后只是用户代理发送该报文。</p>
<p>2）Alice的用户代理把报文发给他的邮件服务器，在那里该报文被放在报文队列中。</p>
<p>3）运行在Alice的邮件服务器上面的SMTP客户端发现了报文队列中的这个报文，他就创建一个到运行在Bob的邮件服务器的SMTP服务器的TCP连接</p>
<p>4）在经过一些初始SMTP握手之后，SMTP客户通过该TCP连接发送Alice的报文。</p>
<p>5）在Bob的邮件服务器上，SMTP的服务器端接收该报文。Bob的邮件服务器然后将该报文放到Bob的邮箱中。</p>
<p>6）在Bob方便的时候，他调用用户代理阅读该报文</p>
<h3 id="值得注意的是"><a href="#值得注意的是" class="headerlink" title="值得注意的是"></a>值得注意的是</h3><p>SMTP一般不适用中间邮件服务器发送邮件，即使两个邮件服务器位于地球的两端也是这样。如果服务器端没有开机的话，则会保留在客户端重复尝试发送报文。</p>
<p>此外，SMTP用的是持续连接，如果发送邮件服务器有多个发向同一个服务器的报文，他们能够通过同样的一个TCP连接进行发送。</p>
<h3 id="SMTP和HTTP的关系"><a href="#SMTP和HTTP的关系" class="headerlink" title="SMTP和HTTP的关系"></a>SMTP和HTTP的关系</h3><ul>
<li>SMTP是推协议，即发送邮件服务器把文件推向接收邮件服务器。TCP连接由发送报文段发起。HTTP是拉协议，即用户使用HTTP从服务器拉取所需要信息。TCP连接由客户端发起。</li>
<li>SMTP要求报文采用7比特ASCⅡ码格式。HTTP则不限制。</li>
<li>HTTP把对象分别封装到各自的而相应报文当中，而SMTP是把所有保温对象放到一个报文当中。</li>
</ul>
<h3 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h3><p>POP3是一个极其简单的邮件访问协议，用于将邮件从接收方的邮件服务器传送到接收方的用户代理。</p>
<p>用户代理打开了一个到邮件服务器端口的TCP连接之后，POP3就开始工作了。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>特许：用户代理发送用户名和密码（明文）以鉴定用户。（命令：list、retr、dele、quit）</p>
<p>事务处理：用户代理取回报文。与此同时，用户代理还能够对报文做删除标记，取消报文删除标记，以及获取邮件的统计信息。（下载并删除 或 下载并保留）</p>
<p>更新：用户发出quit命令后，结束该POP3会话；这时，该邮件服务器删除那些被标记为删除的报文。</p>
<h2 id="DNS（底层使用UDP，运行在53端口）"><a href="#DNS（底层使用UDP，运行在53端口）" class="headerlink" title="DNS（底层使用UDP，运行在53端口）"></a>DNS（底层使用UDP，运行在53端口）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>标识主机方法：IP地址和主机名</p>
<p>路由器喜欢记忆定长的，有结构的IP地址，人喜欢记忆主机名。</p>
<p>DNS处理主机名和IP地址的映射关系。</p>
<p>DNS通常是由其他应用层协议所使用的,将用户提供的主机名解析为IP地址。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559564304860.png" alt="1559564304860"></p>
<h3 id="提供的重要服务"><a href="#提供的重要服务" class="headerlink" title="提供的重要服务"></a>提供的重要服务</h3><ul>
<li><p>主机别名</p>
<p>有着复杂主机名的主机能拥有一个或者多个别名。应用程序可以调用DNS来获取主机别名对应的规范主机名以及主机的IP地址。</p>
</li>
<li><p>邮件服务器别名</p>
<p>电子邮件应用程序可以调用DNS，对提供的主机名别名进行解析，以获取该主机的规范主机名及其IP地址。</p>
</li>
<li><p>负载分配</p>
<p>一个IP地址集合和同一个规范主机名相联系。DNS数据库中存储着这些IP集合，当客户对映射到某地址集合的名字发出一个DNS请求时，该服务器用IP地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常总是向IP地址排在最前面的服务器发送HTTP请求报文，所以DNS就在Web服务器之间循环分配了负载。</p>
</li>
</ul>
<h3 id="工作机理-1"><a href="#工作机理-1" class="headerlink" title="工作机理"></a>工作机理</h3><p>集中式设计存在的问题</p>
<ul>
<li>单点故障</li>
<li>通信容量</li>
<li>远距离的集中式数据库</li>
<li>维护</li>
</ul>
<p>因此 DNS实现是采用分布式，层次结构实现的。</p>
<ul>
<li>根DNS服务器 ：提供TLD服务器的IP地址</li>
<li>顶级域DNS服务器（com、org、net、edu、gov、uk、ca）：都有TLD服务器</li>
<li>权威DNS服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录。可以选择实现自己的权威DNS服务器来保存这些记录或者是支付费用使用某个服务商的权威DNS服务器。</li>
</ul>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559565068865.png" alt="1559565068865"></p>
<p>一个示例</p>
<p>一个DNS客户要决定主机名<a href="http://www.amazon.com的IP地址，他首先和根服务器之一联系，然后根服务器返回顶级域名com的TLD服务器的IP地址,然后该客户再与TLD服务器之一进行联系，它将返回amazon.com的权威服务器IP地址返回，然后该客户在于amazon.com的权威服务器之一进行联系，返回得到所需要的www.amazon.com的IP地址。" target="_blank" rel="noopener">www.amazon.com的IP地址，他首先和根服务器之一联系，然后根服务器返回顶级域名com的TLD服务器的IP地址,然后该客户再与TLD服务器之一进行联系，它将返回amazon.com的权威服务器IP地址返回，然后该客户在于amazon.com的权威服务器之一进行联系，返回得到所需要的www.amazon.com的IP地址。</a>    </p>
<h3 id="本地服务器"><a href="#本地服务器" class="headerlink" title="本地服务器"></a>本地服务器</h3><p>当主机与某ISP连接时，该ISP提供一台主机的IP地址，该主机具有一台或者多台其本地DNS服务器的地址。当主机发出DNS请求是，该请求被发往本地DNS服务器，本地DNS服务器起着代理，缓存的租用。</p>
<ul>
<li>递归查询？以自己的名义</li>
<li>迭代查询？代理去查询</li>
</ul>
<p>当某DNS服务器接受一个DNS回答时，他能将映射缓存到本机存储器中。</p>
<h3 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h3><p>资源记录四元组</p>
<p>（Name, Value, Type, TTL）        </p>
<p>TTL是记录的生存时间</p>
<ul>
<li>Type=A 提供了标准的主机名到IP地址的映射<ul>
<li>Name是主机名，Value是主机名对应的IP地址</li>
<li>（relay1.bar.foo.com, 145.37.93.126,A）</li>
</ul>
</li>
<li>Type=NS 用于沿着查询链来路由DNS查询<ul>
<li>Name是个域，Value是知道如何获取该域中主机IP地址的权威DNS服务器的主机名。</li>
<li>（foo.com,dns.foo.com,NS）</li>
</ul>
</li>
<li>Type=CNAME 记录别名和规范主机名的映射<ul>
<li>Value是别名为Name的主机对应的规范主机名</li>
<li>（foo.com, relay1.bar.foo.com, CNAME）</li>
</ul>
</li>
<li>Type=MX<ul>
<li>Value是个别名为Name的邮件服务器的规范主机名</li>
<li>（foo.com, mail.bar.foo.com, MX）</li>
</ul>
</li>
</ul>
<h3 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h3><p>请求报文和响应报文<strong>格式一样</strong>。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559566619787.png" alt="1559566619787">    </p>
<h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><h2 id="视频流和分发流"><a href="#视频流和分发流" class="headerlink" title="视频流和分发流"></a>视频流和分发流</h2><h2 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>典型的网络应用是由一对程序（客户程序和服务器程序组成的），当运行这两个程序的时候，创建了一个客户进程和一个服务器进程，同时他们通过从套接字读出和写入数据在彼此之间进行通信。</p>
<p>研发阶段在开始要做的以一个决定就是该应用程序是运行在TCP还是UDP上，另外一方面，当代开发者开发的是一个专用应用程序的时候，应该避免使用周知端口号。</p>
<h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>每个进程好比是一座房子，该进程的套接字则好比是一扇门。应用程序位于房子中门的一侧；运输层位于该门朝外的另一侧。应用程序开发者在套接字的应用层一侧可以控制所有东西；然而，他几乎无法控制运输层一侧。</p>
<p>当使用 UDP时，必须先将目的地址附在该分组上。总的来说，发送进程为分组附上目的地址，该目的地址是由目的主机的IP地址和目的地套接字的端口号组成的。此外，发送方的源地址也是由源主机的IP地址和原套接字的端口号组成，该源地址也要附在分组上。然而，将源地址附在分组之上通常并不是由UDP应用程序代码所为，而是由底层操作系统自动完成。</p>
<h4 id="UDPClient-py"><a href="#UDPClient-py" class="headerlink" title="UDPClient.py"></a>UDPClient.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socekt <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#服务器主机名</span></span><br><span class="line">serverName=<span class="string">'hostname'</span></span><br><span class="line"><span class="comment">#服务器的端口号</span></span><br><span class="line">serverPort=<span class="number">12000</span></span><br><span class="line"><span class="comment">#创建了客户的套接字，AF_INET指明的是底层网络使用IPv4,SOCK_DGRAM指明的是该套接字是UDP套接字</span></span><br><span class="line">clientSocket=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"><span class="comment">#发送的报文</span></span><br><span class="line">message=raw_input(<span class="string">'Input lowercase sentence:'</span>)</span><br><span class="line"><span class="comment">#将报文转换成字节类型，然后使用客户套接字的sendto方法发送报文到服务器端</span></span><br><span class="line">clientSocket.sendto(message.encode(),(serverName,serverPort))</span><br><span class="line"><span class="comment">#当一个来自因特网的分组到达该客户套接字时，该分组的数据被放置到变量modifiedMessage中，服务器的IP地址和端口号则被存放到serverAddress中。</span></span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line"><span class="comment">#把接收到的报文数据转换成字符串打印输出</span></span><br><span class="line">print(modifiedMessage.decode())</span><br><span class="line"><span class="comment">#关闭套接字，然后关闭进程</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>

<h4 id="UDPServer-py"><a href="#UDPServer-py" class="headerlink" title="UDPServer.py"></a>UDPServer.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#服务器端口</span></span><br><span class="line">serverPort=<span class="number">12000</span></span><br><span class="line"><span class="comment">#创建服务器套接字，AF_INET指明的是底层网络使用IPv4,SOCK_DGRAM指明的是该套接字是UDP套接字</span></span><br><span class="line">serverSocket=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"><span class="comment">#将端口号12000和该服务器的套接字绑定（分配）到一起。以这种方式，所有人向位于该服务器的IP地址的12000端口发送以恶搞分组，该分组将导向该套接字。</span></span><br><span class="line">serverSocket.bind(<span class="string">''</span>,serverPort)</span><br><span class="line">print(<span class="string">"The server is ready to receive"</span>)</span><br><span class="line"><span class="comment">#允许UDPServer无期限地接受并处理来自客户的分组。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#接收到的报文和客户的地址（IP地址和端口号）分别存储在message和clientAddress中。</span></span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)    </span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    <span class="comment">#将处理后的数据发送返回到客户端</span></span><br><span class="line">    serverSocket.sendto(modefiedMessage.encode(), clientAddress)</span><br></pre></td></tr></table></figure>

<p>#### </p>
<h3 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>TCP是面向连接的协议，这意味着客户在和服务器能够开始互相发送数据之前，他们先要握手和创建一个TCP连接。TCP连接的一段与客户端套接字相联系，另一端和服务器套接字相联系。当创建该TCP连接时，我们将其与客户套接字地址（IP地址和端口号）和服务器套接字地址（IP地址和端口号）关联起来。使用创建的TCP连接，当一侧要向另外一侧发送数据时，他只需要经过其套接字将数据丢进TCP连接。</p>
<p>服务器为了能够对客户的初始接触做出反应，服务器必须已经准备好。</p>
<ul>
<li>TCP服务器在客户试图发起接触前必须作为进程运行起来。</li>
<li>服务器程序必须具有一扇特殊的门，更精准的说是一个特殊的套接字，该门欢迎来自运行在任意主机上的客户进程的某种初始接触。我们可以将初始接触成为“<strong>敲欢迎之门</strong>”。</li>
</ul>
<p>随着服务器进程的运行，客户进程能够向服务器发起一个TCP连接。这是由客户程序通过创建一个TCP套接字完成的。当该客户生成其TCP套接字时，它指定了服务器中的欢迎套接字的地址，及服务器主机的IP地址及其套接字的端口号。生成套接字后，该客户发起了一个三次握手并创建与服务器的一个TCP连接。发生在运输层的三次握手，对于客户和服务器是完全透明的。在三次握手期间，客户进程敲服务器进程的欢迎之门。当该服务器“听”到敲门声时，他将生成一扇新门（更精准的说是一个新套接字），它将用于特定的客户。</p>
<p>从应用程序的角度来说，客户套接字和服务器的连接套接字直接通过一根管道连接。客户进程可以向他的套接字发送任意字节，并且TCP保证服务器进程能够按照发送的顺序接收每个字节。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559283554460.png" alt="1559283554460"></p>
<h4 id="TCPClient-py"><a href="#TCPClient-py" class="headerlink" title="TCPClient.py"></a>TCPClient.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#服务器欢迎套接字地址</span></span><br><span class="line">serverName=<span class="string">'servername'</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line"><span class="comment">#创建客户端套接字，AF_INET是说明底层网络使用的是IPv4,SOCK_STREAM说明的是该套接字是TCP套接字</span></span><br><span class="line">clientSocket = socket(AF_INET,SOCK_STREAM)</span><br><span class="line"><span class="comment">#发起客户和服务器之间的这条TCP连接。</span></span><br><span class="line">clientSocket.connect((serverName,serverPort))</span><br><span class="line">sentence = raw_input(<span class="string">'Input lowercase sentense:'</span>)</span><br><span class="line"><span class="comment">#发送报文，只需要将报文放到TCP连接中即可。</span></span><br><span class="line">clientSocket.send(sentence.encode())</span><br><span class="line">modifiedSentence = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line">print(<span class="string">'From Server:'</span>, modifiedSentence)</span><br><span class="line"><span class="comment">#关闭TCP连接，引起客户中的TCP向服务器中的TCP发送一条TCP报文</span></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>

<h4 id="TCPServer-py"><a href="#TCPServer-py" class="headerlink" title="TCPServer.py"></a>TCPServer.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort=<span class="number">12000</span></span><br><span class="line"><span class="comment">#创建欢迎套接字</span></span><br><span class="line">serverSocket = socket(AF_INET,SOCK_STREAM)</span><br><span class="line"><span class="comment">#绑定端口</span></span><br><span class="line">serverSocket.bind((<span class="string">''</span>,serverPort))</span><br><span class="line"><span class="comment">#等待并聆听某个用户敲门（等待用户的TCP连接请求）</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">"The server is ready to receive"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    sentence = connectionSocket.recv(<span class="number">1024.</span>decode())</span><br><span class="line">    capitalizedSentence = sentence.upper()</span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure>

<h1 id="第三章-运输层"><a href="#第三章-运输层" class="headerlink" title="第三章 运输层"></a>第三章 运输层</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>运输层位于应用层和网络层之间，是分层的网络体系结构的重要部分。<strong>运输层</strong>为运行在<strong>不同主机上的应用进程</strong>之间提供了<strong>逻辑通信功能</strong>。</p>
<p>应用进程使用运输层提供的逻辑通信功能彼此发送报文，而无需考虑承载这些报文的物理基础设施的细节。</p>
<p>运输层协议是在<strong>端系统</strong>中实现运行的。</p>
<ul>
<li>发送端，运输层将应用层传来的报文【可能划分为较小的块】加上运输层首部转换成<strong>运输层分组（运输层报文段）</strong>,然后传送给<strong>网络层</strong>封装成<strong>网络层分组（数据报）</strong>向目的地发送。</li>
<li>接收端，<strong>网络层</strong>从数据包中提取<strong>运输层报文段</strong>，并将该报文段向上交给运输层。运输层处理接收到的报文段，是该报文段中的数据为<strong>接收应用进程</strong>使用。</li>
</ul>
<p>网络层提供了<strong>主机之间的逻辑通信</strong>，而运输层为运行在<strong>不同主机上的进程之间</strong>提供了<strong>逻辑通信</strong>。</p>
<p>一个类比：有两个家庭，一个位于东海岸，一个位于西海岸，每家有12个孩子。这两个家庭的孩子喜欢彼此通信，每个人每星期要互相写一封信，每封信都用单独的信封通过传统的邮政服务传送。因此，每个家庭每周要向另外一个家庭发送144封信。每个家庭有个孩子负责收发邮件，西海岸是Ann而东海岸是Bill。每星期Ann去他的所有的兄弟姐妹那里收集信件，并将这些信件交给每天到家门口来的邮政服务的邮车。当信件到达的时候，Ann也负责将信件分发到她的兄弟姐妹手上，东海岸的Bill也负责类似的工作。</p>
<p>邮政服务为<strong>两个家庭间</strong>提供逻辑通信，邮政服务将信件从<strong>一家送往另一家</strong>，而不是从一个人送往另一个人。在另外一方面，Ann和Bill为<strong>堂兄弟姐妹之间提供了逻辑通信</strong>，Ann和Bill从兄弟姐妹那里收取信件或者到兄弟姐妹那里分发信件。从堂兄弟姐妹的角度来看，Ann和Bill就是邮政服务，尽管他们只是端到端交付过程的一部分。</p>
<p>应用层报文=信封上的字符</p>
<p>进程=堂兄弟姐妹</p>
<p>主机（端系统）=家庭</p>
<p>运输层协议=Ann和Bill</p>
<p>网络层协议=邮政服务（包括邮车）</p>
<p>注意到Ann和Bill都是在各自家里进行工作的，他们并没有参与任何一个中间邮件中心对邮件进行分拣，或者将邮件从一个邮件中心送到另一个邮件中心之类的工作。类似的，<strong>运输层协议</strong>只工作在<strong>端系统</strong>中。在端系统中，运输层协议将来自于应用程序的<strong>报文移到网络边缘（网络层）</strong>，反过来也是一样，但对有关这些报文在网络核心如何移动并不做任何规定。                                                                                            </p>
<p>Ann和Bill提供的服务明显受限于邮政服务所能够提供的服务。比如邮政服务不能提供在两家之间传递邮件所需的最长时间为3天，那么Ann和Bill就不能保证邮件在堂兄弟妹之间传递信件的最长期限。与此类似的，<strong>运输层协议</strong>能够<strong>提供的服务</strong>常常<strong>受限于</strong>底层<strong>网络层协议的服务</strong>类型。                                                                                                                                                                                        </p>
<p>然而，即使底层网络协议不能在网络层提供相应的服务，运输层协议也能提供某些服务。比如底层网络协议不可靠，可能会造成分组丢失、篡改和冗余，运输层协议也能提供可靠的数据传输服务。</p>
<p>TCP、UDP的分组统称为报文段，网络层分组成为数据报。</p>
<p>网络层协议（IP）提供尽力而为的服务，不保证报文段的交付，不保证报文段的按序交付，不保证报文段中的数据的完整性。是不可靠服务。</p>
<p>UDP和TCP的最基本的责任就是将<strong>两个端系统间IP的交付服务</strong>扩展到运行在<strong>端系统上的两个进程之间的交付服务</strong>。</p>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>运输层的多<strong>路复用和多路分解</strong>将网络层提供的主机到主机交付服务<strong>延伸</strong>到运行为在主机上的应用程序提供<strong>进程到进程</strong>的交付服务。</p>
<p>运输层从紧邻其下的网络层接受报文段，然后将这些报文段中的数据交付给在主机上运行的适当的应用进程。</p>
<p>一个进程有一个或多个套接字（SOCKET），它相当于从<strong>网络向进程传递数据和从进程向网络传递数据的门户</strong>。在接受主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交付给了一个中间的套接字。</p>
<p>在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>。在源主机从不同套接字中收集数据块，并未每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong>。</p>
<p>一句话来说就是<strong>多路分解</strong>指的是<strong>接收</strong>，<strong>多路复用</strong>指的是<strong>发送</strong>。</p>
<p>多路复用有两个要求</p>
<ul>
<li>套接字有唯一标识符</li>
<li>每个报文段有特殊字段来指示该报文段所要交付到的套接字。</li>
</ul>
<p>0~1023是周知端口号。</p>
<p>一个类比：</p>
<p>当Bill从邮递员处<strong>收到一批邮</strong>件，并通过查看收件人名字而将信件<strong>亲手交付</strong>给他们的兄弟姐妹时，他执行的就是一个<strong>分解操作</strong>。当Ann从兄弟姐妹那里<strong>收集信件</strong>并将他们<strong>交给邮递员</strong>的时候，她所执行的就是一个<strong>多路复用操作</strong>。 </p>
<h3 id="无连接的多路复用和多路分解（UDP）"><a href="#无连接的多路复用和多路分解（UDP）" class="headerlink" title="无连接的多路复用和多路分解（UDP）"></a>无连接的多路复用和多路分解（UDP）</h3><p>之前的UDP套接字编程之中的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure>

<p>运输层自动为该套接字分配一个端口号。特别是，运输层从1024~65535分配一个端口号。</p>
<p>另外一种方法就是我们通过bind指定关联一个特定的端口号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientSocket.bind((<span class="string">''</span>),<span class="number">19123</span>)</span><br></pre></td></tr></table></figure>

<p>通常，应用程序的客户端让运输层自动地分配端口号，而服务器端则分配一个特定的端口号。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559570362396.png" alt="1559570362396"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559570258660.png" alt="1559570258660"></p>
<h3 id="面向连接的多路复用与多路分解（TCP）"><a href="#面向连接的多路复用与多路分解（TCP）" class="headerlink" title="面向连接的多路复用与多路分解（TCP）"></a>面向连接的多路复用与多路分解（TCP）</h3><p>TCP套接字和UDP套接字之间的一个细微差别是：</p>
<p><strong>TCP套接字</strong>是由一个<strong>四元组</strong>（源IP地址，源端口号，目的IP地址，目的端口号）标识的。当一个TCP报文从网络到达一台主机时，该主机使用<strong>全部4个值</strong>来将报文定向到<strong>相应的套接字</strong>。</p>
<p>服务器主机可以<strong>支持许多并行的TCP套接字</strong>，每个套接字与一个进程相联系，并由其四元组来标识每个<strong>套接字</strong>。</p>
<h3 id="Web与TCP"><a href="#Web与TCP" class="headerlink" title="Web与TCP"></a>Web与TCP</h3><p>Web服务器为每条连接生成一个新进程。每个进程都有自己的连接套接字。通过这些套接字接收HTTP请求和发送HTTP响应。</p>
<p>然而现代可能就不是创建一个新的进程了，而是为每个新的客户连接创建一个具有新连接套接字的新线程。</p>
<h2 id="UDP——不可靠、无连接"><a href="#UDP——不可靠、无连接" class="headerlink" title="UDP——不可靠、无连接"></a>UDP——不可靠、无连接</h2><p>UDP从应用进程得到数据，附加上用于多路复用/分解服务的源和目的端口号字段，以及两个其他的小字段，然后将形成的报文段交给网络层。网络层将该运输层报文段封装到一个IP数据报中，然后尽力而为地将此报文段交付给接受主机。如果该报文段到达接收主机，UDP使用目的端口号将报文段中的数据交付给正确的应用进程。值得注意的是，使用UDP时，在发送报文之前，发送方和接收方的运输层实体之间没有握手。</p>
<h3 id="使用UDP的主要原因"><a href="#使用UDP的主要原因" class="headerlink" title="使用UDP的主要原因"></a>使用UDP的主要原因</h3><ul>
<li>关于发送什么数据以及何时发送的应用层控制更为精细：只要应用进程把数据给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层。</li>
<li>无须连接建立：不会引入额外的时延。</li>
<li>无连接状态：不需要维护连接，可以支持更多的活跃用户。</li>
<li>分组首部开销小：UDP只有8个字节的首部。</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559289045652.png" alt="1559289045652"></p>
<p>UDP的首部只有四个字段，每个字段由两个字节组成。</p>
<ul>
<li>源端口号</li>
<li>目的端口号</li>
<li>UDP长度——指示了在UDP报文段的字节数（首部加数据）</li>
<li>UDP校验和——接收方使用检验和来检查该报文段张是否出现了差错。</li>
</ul>
<h3 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h3><p>发送发的UDP对报文段中的所有16比特子的和进行反码运算，求和时遇到的任何一处都被回卷。</p>
<p>在接受方，全部的比特字加在一起，如果该分组中没有引入差错，在接受方处该和应该是1111111111111111.</p>
<h2 id="可靠传输数据原理"><a href="#可靠传输数据原理" class="headerlink" title="可靠传输数据原理"></a>可靠传输数据原理</h2><p>抽象的来说：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会受到损坏或者丢失，而且所有数据都是按照其发送顺序进行交付。</p>
<p>我们的目的就是开发一个可靠数据传输协议，使得数据在不可靠的信道上面实现可靠传输。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573222448.png" alt="1559573222448"></p>
<h3 id="Rdt1-0——经完全可靠信道的可靠数据传输"><a href="#Rdt1-0——经完全可靠信道的可靠数据传输" class="headerlink" title="Rdt1.0——经完全可靠信道的可靠数据传输"></a>Rdt1.0——经完全可靠信道的可靠数据传输</h3><h4 id="版本简介"><a href="#版本简介" class="headerlink" title="版本简介"></a>版本简介</h4><p>在 1.0 版本中，我们将数据的传输信道理想化，视为完全可靠，不丢包，不损失bit ，在这样的情况下，发送端发送数据，接收端直接接收，并不考虑<strong>丢包，超时</strong>这些问题。</p>
<p>​          <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573364577.png" alt="1559573364577">                                        </p>
<h4 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h4><p>发送端只通过rdt_send(data)从上层应用接收数据，然后调用make_pkt(data)将数据打包之后将数据包放到通道之中通过udt_send(packet)把数据包发送出去。</p>
<h4 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h4><p>接收端通过rdt_rev(packet)从通道中接收数据包，然后使用extract(packet,data)解包，在把data通过deliver_data(data)把data传送到上层应用当中。</p>
<h3 id="Rdt2-0——具有比特差错信道的可靠数据传输"><a href="#Rdt2-0——具有比特差错信道的可靠数据传输" class="headerlink" title="Rdt2.0——具有比特差错信道的可靠数据传输"></a>Rdt2.0——具有比特差错信道的可靠数据传输</h3><h4 id="版本简介-1"><a href="#版本简介-1" class="headerlink" title="版本简介"></a>版本简介</h4><p>果然，大家应该都意识到了，怎么可能这么理想化呢，要是传输通道完全可靠，我们讨论的意义何在呢？<br> 在 rdt2.0 中，我们将传输通道视为<strong>有可能发生比特错误</strong>。</p>
<p>有可能发生比特错误，这就是说，数据在传输中不会发生丢包的现象，但是会存在一部分比特错误的情况。因此我们就在2.0版本中引入了下面的三个机制。</p>
<p>差错检测：使用<strong>检验和</strong>，换句话讲，就是检验发过来的包有没有错误<br> 接收方的反馈：接收方返回 NAK 或者 ACK ，分别对应数据错误和数据正确，这个也可以理解，总要告诉发送端，你发过来的是对还是错。</p>
<p>重传：接收方收到有差错的分组的时候，发送方将重传该数据包。</p>
<p>​          <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573408086.png" alt="1559573408086">                                        </p>
<p>【注】corrupt字典中是腐烂的意思，这里可以理解为数据包出错。</p>
<h4 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h4><p>发送端总共有两个状态。左边的状态的时候，发送端等待上层应用传下来的数据。</p>
<p>和1.0一样，调用rdt_sent(data)从上层应用接收数据，然后用make_pkt(data,checksum)</p>
<p>对数据进行打包，然后在用udt_send(sndpkt)把数据包发送出去。发送出去之后就跳转到了右边的等待状态，等待接收端发回的ACK或者是NAK包。在此就有两种处理机制，收到ACK包的话，发送端就跳转回到左边的状态。但是如果收到的是NAK包的话，就说明接受端接收到的之前发送的那个数据包出错了，需要重发。发送端就会使用udt_send(sndpkt)重新发送一遍之前发送的那个数据包，发送之后仍然处于右边的状态等待接受端发送回来的ACK或者是NAK包。</p>
<h4 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h4><p>接收端仍旧只有一个状态。接收端通过rdt_rcv(rcvpkt)从管道内接收到数据包，然后会对该数据包进行检查。检查的时候就会有两个处理分支。如果数据包没有损坏的话（也就是notcorrupt(rcvpkt)==true），接收端就会调用extract(rcvpkt,data)对数据包进行解包然后用deliver_data(data)把数据传输到上层应用之中，同时也会使用make_pkt(ACK)打包一个ACK确认包发送到发送端告诉发送端自己已经收到了正确的数据包，发送端可以发送下一个数据包了。但是倘若对数据包检查发现数据包受损的话（也就是corrupt(rcvpkt)==true），接收端就会通过make_pkt(NAK)打包一个NAK包发送给发送端告诉发送端自己收到的是一个受损的数据包，要求发送端重传一遍数据。</p>
<h3 id="Rdt2-1"><a href="#Rdt2-1" class="headerlink" title="Rdt2.1"></a>Rdt2.1</h3><h4 id="版本简介-2"><a href="#版本简介-2" class="headerlink" title="版本简介"></a>版本简介</h4><p>经过大家思考，终于发现了 rdt2.0 的致命缺陷，原来接收端返回的值也可能会出错啊，万一NAK出错变成ACK了呢.这样的话发送方就无从得知接受方是否接收到了正确的数据。</p>
<p>于是诞生了 rdt2.1 ，该协议在 2.0 基础上增加了一个序号值（在这里，该序号在当前协议中只使用 0 和1 ，交替排列），这样一来，发送端和接收端都有了两种序号状态， 0 和 1 。</p>
<h4 id="发送端-2"><a href="#发送端-2" class="headerlink" title="发送端"></a>发送端</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573494833.png" alt="1559573494833"></p>
<p>发送方此时有四个状态，基本逻辑都差不多。初始时处于左上角的状态，从上层应用接收到数据然后通过make_pkt(0,data,checksum)打包将数据发送出去，然后跳转到右边等待的状态。此时收到NAK包就重传，收到ACK包的话就跳到下一个状态准备发送下一个数据包。</p>
<p>下面的逻辑基本和上面相同，区别只是在于打包的时候附上的标识码不一样，下面的就是make_pkt(1,data,checksum)</p>
<h4 id="接收端-2"><a href="#接收端-2" class="headerlink" title="接收端"></a>接收端</h4><p>​             <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573553642.png" alt="1559573553642">                                     </p>
<p>接收端有两个状态，初始状态的时候从管道中取得数据包，然后对数据包检查，如果说收到的是一个损坏的包的话，就发送NAK包给发送端。如果收到的是一个完整的包的话，就会对数据包的序列号进行检查，如果数据包的序列号和当前匹配的话（此时是0）就会对数据包进行解包传送到上层应用之中，然后跳转到下一个状态，更改等待的数据包的序列号。如果数据包的序列号和当前不匹配的话，就会给发送端发送一个ACK包，但是接收端的状态并不会跳转，表示接收端希望接收到的数据包仍然是当前的这个数据包。此时发送端收到ACK的话，就会跳转到下一个状态发送接收端所期待的数据包了。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h4 id><a href="#" class="headerlink" title></a><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573571173.png" alt="1559573571173"></h4><h3 id="Rdt2-2"><a href="#Rdt2-2" class="headerlink" title="Rdt2.2"></a>Rdt2.2</h3><h4 id="版本简介-3"><a href="#版本简介-3" class="headerlink" title="版本简介"></a>版本简介</h4><p>由于相关开发人员的吹毛求疵，他们觉得需要返回 NAK , ACK 两种状态可能太麻烦了，就将其全部改为ACK 只是返回的时候顺便返回序号。 </p>
<h4 id="发送端-3"><a href="#发送端-3" class="headerlink" title="发送端"></a>发送端</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573595996.png" alt="1559573595996"></p>
<h4 id="接收端-3"><a href="#接收端-3" class="headerlink" title="接收端"></a>接收端</h4><p>​            <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573612593.png" alt="1559573612593">                                      </p>
<p>可以看到，接收端收到包，不管正确与否，都返回 ACK ，同时附上序号，这个序号嘞，就是数据包发送过来时的序号。</p>
<h3 id="Rdt3-0——具有比特差错的丢包信道的可靠数据传输"><a href="#Rdt3-0——具有比特差错的丢包信道的可靠数据传输" class="headerlink" title="Rdt3.0——具有比特差错的丢包信道的可靠数据传输"></a>Rdt3.0——具有比特差错的丢包信道的可靠数据传输</h3><h4 id="版本简介-4"><a href="#版本简介-4" class="headerlink" title="版本简介"></a>版本简介</h4><p>可以说，在处理数据出错方面，上面的协议都做得很好了，但是，我们忽略了一个很大的问题，万一数据不是出现错误，而是直接丢失了呢！！这就是我们俗称的<strong>丢包</strong>了。</p>
<p>所以在这里，我们假设的是最贴近真实的情况，数据传输通道发送和返回的过程中不仅会出错，而且还会丢包！</p>
<p>因此，我们引入了一个新的机制—超时重传。在这里，我们让发送发负责检测和恢复丢包工作。</p>
<p>先不考虑数据出错与否，数据发送出去，会有两种丢包可能：1.发送出去的时候丢失，接收端并未收到 。2.接收端收到了，但是在反馈 ACK 的时候，数据包丢失。在这两种情况下，发送端都是什么反馈都没有收到！！，那问题就简单了，我们设置一个时间间隔，超过时间没有收到，重新发送数据即可。（事实上还有很多问题，比如时间间隔多少合适，这里暂且不管） </p>
<h4 id="发送端-4"><a href="#发送端-4" class="headerlink" title="发送端"></a>发送端</h4><p>​             <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573644090.png" alt="1559573644090">                                     </p>
<p>上图是 rdt3.0 发送方的 FSM 图，就拿右上角的状态举例，此时发送端等待接收方返回的带有“0”序号的 ACK ，它有三种行为：</p>
<p>第一种，过程中未丢包，但是数据比特出错或者不符合序号，和我们讨论过的 rdt2.2 差不多，那么此时就没有任何动作，毫无作为就好了，等到时间间隔一到，当做超时处理，重发数据。</p>
<p>第二种，是真正的丢包了，所以时间一到，重新发送。</p>
<p>第三种最理想，啥事没有，一切正常，跳到下一个状态，等待发送下一个包。</p>
<p>这里的不符合序号，与期待的序号不符，有两种情况：</p>
<p>1.接收端反馈过程中，代表序号的那个 bit 错误，进行了翻转——这就和 rdt2.2 中一样</p>
<p>2.我们上面引入了超时机制，但是有一种情形，万一我发出去的数据包并没有丢失，只是它跑的太慢而已呢？？那么时间一到，发送端误以为丢包，重新发了一遍咋办？？这就造成，接收端才收到你晚来的数据 0 号，还给你个 0 ，这时候你重传的 0 号包接着又到了，接收端又给你一个0 ，作为发送端，我会先后收到两个 0 ，就注定后面一个 0 会被期待 1 号的状态捕捉，这时发送端启动第一种处理方式——不作为，啥都不做。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559573656642.png" alt="1559573656642"></p>
<h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616030731.png" alt="1559616030731"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616044080.png" alt="1559616044080"></p>
<p>使用停等协议会使得发送方效率极低，因此就有人想出了流水线可靠数据传输协议。</p>
<p>不以停等方式运行，允许发送发发送多个分组而无需等待确认。就像3-18.b所示，待确认之前发送3个分组，效率也就提高了3倍。                     </p>
<p>对于差错处理，流水线有两种方法：回退N步和选择重传</p>
<h3 id="回退N步（GBN"><a href="#回退N步（GBN" class="headerlink" title="回退N步（GBN)"></a>回退N步（GBN)</h3><p>base:最早未确认分组的序号</p>
<p>nextseqnum:最小的未使用符号（及下一个待发分组的序号）</p>
<p>[0,base-1] :已经发送并被确认的分组</p>
<p>[base,nextseqnum-1]：已经发送但未被确认的分组</p>
<p>[nextseqnum,base+N-1] ：序号能用于哪些要被立即发送的分组</p>
<p>[base+N，+∞] ：不能使用的序号，知道前面的分组被确认</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616523633.png" alt="1559616523633"></p>
<h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616582889.png" alt="1559616582889"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616674323.png" alt="1559616674323"></p>
<h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616593718.png" alt="1559616593718"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616702009.png" alt="1559616702009"></p>
<p>接收方必须按需将数据交付给上层，<strong>丢弃所有失序分组</strong>。</p>
<p>这种方法的优点是<strong>接收缓存简单</strong>，他不必维护任何失序分组。</p>
<p>接收方需要<strong>维护的唯一信息</strong>就是<strong>下一个按序接收的分组的序号</strong>。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559616866643.png" alt="1559616866643"></p>
<h3 id="选择重传-SR"><a href="#选择重传-SR" class="headerlink" title="选择重传  (SR)"></a>选择重传  (SR)</h3><p>选择重传协议通过让发送方仅重传那些他怀疑在接受方出错的分组而避免了不必要的重传。</p>
<p>SR接收方将确认一个正确接收的分组而不管他是否按序。失序的分组将被缓存知道所有丢失分组（及序号更小的分组）皆被找到为止，这时才可以将一批分组按序交付给上层应用。</p>
<h4 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617619691.png" alt="1559617619691"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617566071.png" alt="1559617566071"></p>
<h4 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617659417.png" alt="1559617659417"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617677948.png" alt="1559617677948"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559617741490.png" alt="1559617741490"></p>
<h2 id="TCP——可靠、面向连接"><a href="#TCP——可靠、面向连接" class="headerlink" title="TCP——可靠、面向连接"></a>TCP——可靠、面向连接</h2><p>TCP连接是一种<strong>逻辑上的连接</strong>，其共同状态仅保留在两个通信端系统的TCP程序中。TCP协议只在<strong>端系统</strong>之中运行，而不再中间的网络元素中运行。中间路由器对TCP报文完全视而不见，他们看到的只是数据报，而不是连接。</p>
<p>TCP是一种<strong>全双工服务</strong>，意思就是连通之后能够互相发送报文（数据）。同时，TCP也是一种点对点的协议。</p>
<p>TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段，这些保温段被下传给网路层，网络层将其分别封装在网络层IP数据报中，然后这些IP数据报被发送到网络中。</p>
<p>TCP连接的组成包括：<strong>一台主机上的缓存</strong>、<strong>变量</strong>和与<strong>进程连接的套接字</strong>。</p>
<p>​                                                                                 </p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559613248514.png" alt="1559613248514"></p>
<p>TCP把数据看成一个<strong>无结构的、有序的字节流</strong>，序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。</p>
<h3 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h3><p>TCP的报文结构如下所示</p>
<p>​      <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559613509468.png" alt="1559613509468">                                            </p>
<p>源端口和目的端口：</p>
<p>各占2个字节，这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。有时一个IP地址和一个端口号也称为socket（插口）。</p>
<p>seq序号：</p>
<p>占4个字节，是本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而且数据共100字节，则下一个报文段的序号就是400；序号是32bit的无符号数，序号到达2^32-1后从0开始。</p>
<p>ack确认序号：</p>
<p>占4字节，是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号；确认序号应该是上次已成功收到数据字节序号+1。只有ACK标志为1时，确认序号才有效。</p>
<p>数据偏移：</p>
<p>占4比特，表示数据开始的地方离TCP段的起始处有多远。实际上就是TCP段首部的长度。由于首部长度不固定，因此数据偏移字段是必要的。数据偏移以32位为长度单位，也就是4个字节，因此TCP首部的最大长度是60个字节。即偏移最大为15个长度单位=1532位=154字节。</p>
<p>保留：</p>
<p>​    6比特，供以后应用，现在置为0。</p>
<p>6个标志位比特：</p>
<p>① URG：当URG=1时，注解此报文应尽快传送，而不要按本来的列队次序来传送。与“紧急指针”字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长。</p>
<p>② ACK：只有当ACK=1时，确认序号字段才有效；</p>
<p>③ PSH：当PSH=1时，接收方应该尽快将本报文段立即传送给其应用层。</p>
<p>④ RST：当RST=1时，表示出现连接错误，必须释放连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接；</p>
<p>⑤ SYN：SYN=1,ACK=0时表示请求建立一个连接，携带SYN标志的TCP报文段为同步报文段；</p>
<p>⑥ FIN：发端完成发送任务。</p>
<p>窗口：</p>
<p>TCP通过滑动窗口的概念来进行流量控制。设想在发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制，协调好通信双方的工作节奏。所谓滑动窗口，可以理解成<strong>接收端所能提供的缓冲区大小</strong>。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓冲区。窗口大小为字节数起始于确认序号字段指明的值（这个值是接收端正期望接收的字节）。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。</p>
<p>检验和：</p>
<p>检验和覆盖了整个TCP报文段：TCP首部和数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p>
<p>紧急指针：</p>
<p>只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p>
<p>TCP之确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供<strong>累积确认</strong>。</p>
<p>​    </p>
<h3 id="往返时间的估计与超时"><a href="#往返时间的估计与超时" class="headerlink" title="往返时间的估计与超时"></a>往返时间的估计与超时</h3><p>大多数的TCP实现仅在某个时刻做一个SampleRTT测量，也就是说在任意是个，仅为一个已发送的但目前尚未被确认的报文段估计SampleRTT。因为会波动，所以要多次测量不断更新。<br>$$<br>EstimatedRTT=0.875✖EstimatedRTT+0.125✖SampleRTT<br>$$</p>
<p>测量RTT的变化也是有价值的。<br>$$<br>DevRTT=0.75✖DevRTT+0.25✖|SampleRTT-EstimatedRTT|<br>$$</p>
<p>所以一般情况下，重传超时间隔的设定一般设定为<br>$$<br>TimeoutInterval=EstimatedRtt+4✖DevRTT<br>$$</p>
<h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流，即该字节流与连接的另一方端系统发出的字节流是完全相同的。</p>
<p>TCP发送方三个和发送与重传相关的事件</p>
<ul>
<li>从上层应用程序接收数据</li>
<li>定时器超时</li>
<li>收到ACK</li>
</ul>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559629284091.png" alt="1559629284091"></p>
<p>三个简单情况</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559629300456.png" alt="1559629300456"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559629307513.png" alt="1559629307513"></p>
<h4 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h4><p>定时器在接受到上层应用数据和收到ACK时，TimoutInterval由最近的EstimatedRTT的值和DevRTT推算得到。</p>
<p>而在超时事件当中，超时间隔是设定为之前的两倍而不是由这两个值决定，这种修改提供了一种形式受限的拥塞控制。定时器过期很可能是由网络拥塞引起的，如果持续重传分组，只会使得网络更加拥堵。</p>
<h4 id="快速重传（162？？？）"><a href="#快速重传（162？？？）" class="headerlink" title="快速重传（162？？？）"></a>快速重传（162？？？）</h4><h4 id="差错恢复机制（GBN和SR的结合？？？）"><a href="#差错恢复机制（GBN和SR的结合？？？）" class="headerlink" title="差错恢复机制（GBN和SR的结合？？？）"></a>差错恢复机制（GBN和SR的结合？？？）</h4><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP为他的应用程序提供了流量控制服务以消除发送方使接收方缓存溢出的可能性，因此流量控制是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。</p>
<p>TCP通过让发送方维护一个称为接收窗口的变量来提供流量控制。通俗的说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。</p>
<p>假定主机A通过一条TCP连接向主机B发送一个大文件，主机B为该连接分配了一个接收缓存，并用RcvBuffer来标识这个大小。主机B的应用程序不时从该缓存中读取数据，我们定义如下的变量。</p>
<ul>
<li>LastByteRead:主机B上的应用程序从缓存读出的数据流的最后一个字节的编号</li>
<li>LastByteRevd:从网络到达并且已放入主机B接收缓存的数据流的最后一个字节的编号。</li>
</ul>
<p>我们需要做到的就是保证<br>$$<br>LastByteRevd-LastByteRead≤RcvBuffer<br>$$<br>接收窗口用rwnd标识<br>$$<br>rwnd =RcvBuffer-[LastByteRevd-LastByteRead]<br>$$<br>主机B通过把rwnd的值放到对A的报文当中告诉A他还剩多少可用空间。</p>
<p>另一方面，主机A跟踪两个变量</p>
<ul>
<li>LastByteSent:主机A上发送到连接的数据量</li>
<li>LastByteAcked:主机A上发送到连接并且被确认的数据量</li>
</ul>
<p>对于A来说要满足<br>$$<br>LastByteSent-LastByteAcked≤rwnd<br>$$</p>
<p>此处有个特殊情况需要考虑，就是当rwnd为0的时候，A会继续发送只有一个字节数据的报文段，这样的话，当缓存有空闲的时候，就会发送一个ACK给A。</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><p>​                                                  </p>
<p>   <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630881617.png" alt="1559630881617"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630886302.png" alt="31559630886302"></p>
<p>  <strong>第一次握手</strong></p>
<p>​      客户端向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时随机生成初始序列号 seq=x，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状</p>
<p>态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。（你好，我是客户端A,我想建立连接）。</p>
<p>  <strong>第二次握手</strong></p>
<p>​      TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己随机初始化一个序列号 seq=y，此</p>
<p>时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端</p>
<p>是否准备好。（你好，我是服务器端B,我准备好建立连接了，你呢？）。</p>
<p>  <strong>第三次握手</strong></p>
<p>​      TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。</p>
<p>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。这里客户端表示我已经准备好。（好的，B，我也准备好建立连接了）</p>
<p><strong>为什么要三次握手呢，有人说两次握手就好了</strong></p>
<p>已失效的连接请求报文段。</p>
<p>   client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会向client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起来了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。</p>
<h4 id="四次挥手断开连接"><a href="#四次挥手断开连接" class="headerlink" title="四次挥手断开连接"></a>四次挥手断开连接</h4><p>客户端和服务器端均可主动发起断开请求（挥手动作）！</p>
<p> <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630937911.png" alt="1559630937911"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630941591.png" alt="1559630941591"></p>
<p>​                                                  </p>
<p>第一次挥手</p>
<p>主动方收到来自上层应用的断开连接的信号的时候，就会发送一个FIN被设置为1的数据包给被动端表示断开连接的请求（A:我想断开连接）。发送完数据包之后，主动端就进入了FIN_WAIT1状态（可以接收、应答数据，但是不能发送数据）。此时主动端的控制权就交给了kernel端，程序就不再管理了。</p>
<p>第二次挥手</p>
<p>被动端收到了主动端第一次挥手发送过来的FIN为1的数据包，就会向主动端发送一个ACK数据包表示自己已经收到了第一次挥手发送的数据包。（B:我知道你想断开连接啦！）此时，被动端也会告诉自己的上层应用准备关闭服务。被动端就转换到了CLOSE_WAIT状态，等待被动端上层APP处理断开请求。</p>
<p>第三次挥手</p>
<p>当被东端上层应用处理完断开请求之后，被动端就会发送自己的终止报文段（FIN也被设置为1），表明被动端上层的断开连接的相关工作已经完成。（B:我已经断开连接了！）然后被动端就转换到了LAST-ACK状态等待主动方发送的ACK包。（也就是等待A告诉自己A已经知道了B断开连接了）。</p>
<p>第四次挥手</p>
<p>主动端收到被动端发送过来的FIN数据包，然后返回一个ACK包给被动端告诉他自己已经收到了它的FIN包了（我知道你准备好断开连接了，正式断开连接！）。当被动端收到ACK包之后，就会跳转到CLOSE状态了。发送完ACK包之后，主动端就进入了TIME_WAIT状态，如果说发送给被动端的ACK包丢失了的话，就会重传这个ACK包。经过一定的等待时间之后，连接就正式关闭了。主动端的所有资源将被释放。</p>
<h5 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h5><p>客户端</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630949197.png" alt="1559630949197"></p>
<p>服务器端</p>
<p>   <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559630955296.png" alt="1559630955296"></p>
<h2 id="拥塞控制（？？？）"><a href="#拥塞控制（？？？）" class="headerlink" title="拥塞控制（？？？）"></a>拥塞控制（？？？）</h2><p>防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>端到端拥塞控制：</li>
<li>网络辅助的拥塞控制：路由器像发送方提供网络的反馈信息</li>
</ul>
<ul>
<li><p>怎么降低发送速率</p>
<ul>
<li>LastByteSent-LastByteAcked≤</li>
</ul>
</li>
<li><p>如何感知路径上面存在拥塞</p>
<ul>
<li>要么出现超时，要么收到三个冗余的ACK</li>
</ul>
</li>
<li><p>感知到拥塞的时候怎么去调节发送速率</p>
<ul>
<li>TCP原则<ul>
<li>一个丢失的报文意味着拥塞，应该降低发送速率</li>
<li>一个确认报文段只是网络正在正常发送数据，应该增加发送速率</li>
<li>带宽探测（像小孩子要糖一样）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="慢启动（slow-start-AIMD）"><a href="#慢启动（slow-start-AIMD）" class="headerlink" title="慢启动（slow start   AIMD）"></a>慢启动（slow start   AIMD）</h4><p>以一个MSS为开始的</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559732109367.png" alt="1559732109367"></p>
<p>慢启动——》拥塞避免——》快速恢复</p>
<p>RTT指数增加    RTT增加一个MSS </p>
<h5 id="指数增加"><a href="#指数增加" class="headerlink" title="指数增加"></a>指数增加</h5><h5 id="加法增加"><a href="#加法增加" class="headerlink" title="加法增加"></a>加法增加</h5><p>是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞</p>
<h5 id="乘法减少"><a href="#乘法减少" class="headerlink" title="乘法减少"></a>乘法减少</h5><p>出现一次超时（即出现一次网络拥塞），就把慢开始门限值ssthresh设置为当前的拥塞窗口值乘以0.5</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p><a href="https://blog.csdn.net/dangzhangjing97/article/details/81008836" target="_blank" rel="noopener">https://blog.csdn.net/dangzhangjing97/article/details/81008836</a></p>
<h1 id="第四章-网络层：数据平面"><a href="#第四章-网络层：数据平面" class="headerlink" title="第四章 网络层：数据平面"></a>第四章 网络层：数据平面</h1><p>网络层的数据平面即网络层中每台路由器的功能，该数据平面决定到达路由器输入链路之一的数据报如何转发到该路由器的输出链路之一。</p>
<h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><p>每台路由器的数据平面的主要任务是从其输入链路向去输出链路转发数据报。</p>
<ul>
<li>转发：分组到达路由器的一条输入链路的时候，路由器必须将该分组移动到适当的输出链路</li>
<li>路由选择：分组从发送方流向接收方的时候，网络层需要决定这些分组所采用的路径。</li>
</ul>
<p>每个路由器中都有转发表用来检查分组首部，然后检索到对应的输出链路。</p>
<p>两种方法</p>
<ul>
<li>传统方法：路由选择进行在路由器中</li>
<li>SDN方法：路由选择运行在远程控制器中</li>
</ul>
<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p>查找功能：查找转发表决定输出端口。</p>
<p>转发表从路由选择处理器经过独立总线复制到线路卡</p>
<p>一旦通过查找确定了某个分组的输出链路的话，该分组就能够发送进入交换组织。</p>
<p> <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633361684.png" alt="1559633361684"></p>
<p>​                                                  </p>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><p>将路由器的输入端口连接到他的输出端口</p>
<h4 id="经过内存交换"><a href="#经过内存交换" class="headerlink" title="经过内存交换"></a>经过内存交换</h4><p>分组从输入端口处复制到处理器内存中，处理器提取头部目的地址然后再转发表中寻找输出端口，然后把分组复制到输出端口的缓存中。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633388589.png" alt="1559633388589"></p>
<h4 id="经总线交换"><a href="#经总线交换" class="headerlink" title="经总线交换"></a>经总线交换</h4><p>输入分组到路由器之后标上一个标签，然后通过总线向所有输出端口发送数据，与之匹配的输出端口就保存该分组，然后去除标签。</p>
<p>   <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633393341.png" alt="1559633393341"></p>
<h4 id="经互联网网络交换"><a href="#经互联网网络交换" class="headerlink" title="经互联网网络交换"></a>经互联网网络交换</h4><p>通过内部线路设计实现互联的发送分组</p>
<p>   <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633408224.png" alt="1559633408224"></p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>输出端口存储从交换结构接受的分组</p>
<p> <img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633418278.png" alt="1559633418278"></p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><h4 id="输入排队"><a href="#输入排队" class="headerlink" title="输入排队"></a>输入排队</h4><p>多个输入端口竞争同一个输出端口，就会造成线路前部阻塞。可能会造成丢包。</p>
<h4 id="输出排队"><a href="#输出排队" class="headerlink" title="输出排队"></a>输出排队</h4><p>到达的速率比传出的速率快，导致内存占满，就会采用丢弃新到达的分组（弃尾），或者是丢弃已经再缓存中的分组为新到达的分组从腾出空间</p>
<h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><ul>
<li><p>先进先出</p>
</li>
<li><p>优先权排队</p>
</li>
<li><p>循环和公平加权排队</p>
</li>
</ul>
<h2 id="网络协议：IPv4、寻址、IPv6及其他"><a href="#网络协议：IPv4、寻址、IPv6及其他" class="headerlink" title="网络协议：IPv4、寻址、IPv6及其他"></a>网络协议：IPv4、寻址、IPv6及其他</h2><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><h4 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559633652962.png" alt="1559633652962"></p>
<ul>
<li>协议：这个字段指示了IP数据报的数据部分应交给哪个特定的运输层协议。例如6是TCP，17是UDP。协议号是将网络层和运输层绑定到一起的粘合剂，而端口号是将运输层和应用层绑定到一起的粘合剂。</li>
</ul>
<h4 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h4><p>不是所有链路层协议都能承载相同长度的网络层分组。一个链路层帧能承载的最大数据量叫最大传送单元（MTU)。</p>
<p>IP分组对于链路层较大的时候，就需要对IP数据报进行分割，分割之后较小的数据报叫做片。片在到达目的地第运输层以前需要重新组装。数据包的重新组装工作实在端系统中的。</p>
<p>当某路由器对一个数据报分片时，形成的片具有初始数据报的源地址，目的地址和标识号。最后一个片的标志比特位被置为0，其他的则为1，另外，为了让目的主机确认是否丢失了一个片，使用偏移字段指定该片应该放在初始数据报的那个位置。</p>
<h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>主机与物理链路之间的边界叫做接口。一个IP地址和一个接口相关联。</p>
<p>子网</p>
<p>子网掩码</p>
<p>无类别域间路由选择</p>
<p>IP地址 a.b.c.d/x</p>
<p>当该组织外部的一台路由器转发一个数据报的时候，著需要考虑前x比特。 后面的比特用于区别组织内部设备。</p>
<p>255.255.255.255用于向同一网络中的所有主机进行广播。</p>
<h4 id="获取IP地址"><a href="#获取IP地址" class="headerlink" title="获取IP地址"></a>获取IP地址</h4><ul>
<li>手动分配配置IP地址</li>
<li>DHCP动态分配地址<ul>
<li>DHCP又称为即插即用协议或零配置协议。</li>
<li>DHCP是一个客户-服务器协议，客户时新到达的主机，服务器是DNCP服务器</li>
<li>分配步骤<ul>
<li><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634680014.png" alt="1559634680014"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h3><p>NAT使能路由器对外部世界来说甚至不像一台路由器。路由器从ISP的DHCP服务器获得他的地址，然后这个路由器在运行一个DHCP服务器，为位于NAT-DHCP路由器控制的网络空间中的主机提供地址。</p>
<p>NAT路由器上面有一个NAT转换表，表项中包含了端口号和IP地址。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634928167.png" alt="1559634928167"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634934408.png" alt="1559634934408"></p>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><h4 id="数据报格式-1"><a href="#数据报格式-1" class="headerlink" title="数据报格式"></a>数据报格式</h4><p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559634962368.png" alt="1559634962368"></p>
<h4 id="IPv4到IPv6的迁移"><a href="#IPv4到IPv6的迁移" class="headerlink" title="IPv4到IPv6的迁移"></a>IPv4到IPv6的迁移</h4><p>建隧道</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559635101748.png" alt="1559635101748"></p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559635116676.png" alt="1559635116676"></p>
<h2 id="通用转发和SDN（？？？231）"><a href="#通用转发和SDN（？？？231）" class="headerlink" title="通用转发和SDN（？？？231）"></a>通用转发和SDN（？？？231）</h2><h1 id="第五章-网络层：控制平面"><a href="#第五章-网络层：控制平面" class="headerlink" title="第五章 网络层：控制平面"></a>第五章 网络层：控制平面</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>转发表和流表是如何计算、维护、安装的。</p>
<ul>
<li>每路由控制：每个路由器中运行一种路由选择算法</li>
<li>逻辑集中控制：逻辑集中是控制器计算并分发转发表以供每台路由器使用。</li>
</ul>
<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><p>目的是从发送方到接收方的过程中确定一条通过路由器网络的好的路径（等价于路由）。</p>
<ul>
<li>集中式路由选择算法：用完整的、全局的网络只是计算出从原到目的地之间的最低开销路径。</li>
<li>分散式路由选择算法：以迭代的、分布式的方式计算出最低开销路径。</li>
</ul>
<h3 id="链路状态路由选择算法（LS）"><a href="#链路状态路由选择算法（LS）" class="headerlink" title="链路状态路由选择算法（LS）"></a>链路状态路由选择算法（LS）</h3><h3 id="距离向量路由选择算法（DV）"><a href="#距离向量路由选择算法（DV）" class="headerlink" title="距离向量路由选择算法（DV）"></a>距离向量路由选择算法（DV）</h3><h2 id="OSPF：因特网中自治系统内部的路由选择"><a href="#OSPF：因特网中自治系统内部的路由选择" class="headerlink" title="OSPF：因特网中自治系统内部的路由选择"></a>OSPF：因特网中自治系统内部的路由选择</h2><p>在相同AS中的路由器都运行相同的路由选择算法并且有彼此的信息。在一个自治系统内运行的路由选择算法叫做自治系统内部路由选择协议。</p>
<ul>
<li>OSPF是之中链路状态协议，它使用洪范链路状态信息和Dijkstra最低开销算法。一个路由器构建了一幅关于整个自治系统的完整拓扑图。然后每台路由器在本地运行Dijkstra的最短路径算法，以确定一个以自身为根节点到所有子网的最短路径树。</li>
<li>使用OSPF时，路由器想自治系统内<strong>所有其他路由器</strong>广播路由选择信息。</li>
</ul>
<p>优点</p>
<ul>
<li>安全。经由受信任的路由器内参与一个AS内的OSPF协议。</li>
<li>多小相同开销路径</li>
<li>对单播与多播路由选择的综合支持。</li>
<li>支持在单个AS中的层次结构</li>
</ul>
<h2 id="BGP-ISP之间的路由选择"><a href="#BGP-ISP之间的路由选择" class="headerlink" title="BGP :ISP之间的路由选择"></a>BGP :ISP之间的路由选择</h2><p>自治系统间路由选择协议</p>
<p>BGP边界网关协议</p>
<ul>
<li>从邻居AS获得前缀的可达性信息</li>
<li>确定到该前缀的最好路由</li>
</ul>
<p>路由器要么是一台网关路由器，要么是一台内部路由器</p>
<p>外部BGP连接：两个路由器位于不同的AS</p>
<p>内部BGP连接：两个路由器位于相同的AS</p>
<p>BGP属性</p>
<ul>
<li>AS-PATH</li>
<li>NEXT-HOP</li>
</ul>
<h3 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h3><p>内部最短</p>
<h3 id="路由器选择算法"><a href="#路由器选择算法" class="headerlink" title="路由器选择算法"></a>路由器选择算法</h3><p>本地偏好–&gt;AS个数–&gt;热土豆路由–&gt;BGP标识符</p>
<h3 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h3><h3 id="路由选择策略"><a href="#路由选择策略" class="headerlink" title="路由选择策略"></a>路由选择策略</h3><h2 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h2><h2 id="ICMP-：因特网控制报文协议"><a href="#ICMP-：因特网控制报文协议" class="headerlink" title="ICMP ：因特网控制报文协议"></a>ICMP ：因特网控制报文协议</h2><h2 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h2><p>请求响应模式</p>
<p>陷阱报文（异常情况）</p>
<p>PDU</p>
<h1 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h1><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><p>运行链路层的任何设备均称为节点（主机、路由器、交换机、WIFI接入点等等）。沿着通信路径相连的通信信道称为链路。</p>
<p>旅行社——路由选择协议</p>
<p>游客——数据报</p>
<p>运输区段——链路</p>
<p>运输方式——链路层协议</p>
<p>链路层提供的服务：</p>
<ul>
<li>成帧：在每个网络层数据报经链路传送之前，几乎所有的链路层协议都要用链路层帧封装起来。</li>
<li>链路接入：媒体控制访问（MAC）协议规定了帧在链路上传输的规则。</li>
<li>可靠交付：当链路层协议提供可靠交付服务是，他保证无差错地经链路层移动每个网络层数据报。但是许多有限的链路层协议不提供可靠交付服务</li>
<li>差错检测和纠正：让发送节点在帧中包括差错检测比特，让接收节点进行差错检查。</li>
</ul>
<p>链路层是现在路由器的线路卡中。</p>
<p>在发送端，控制器取得了有协议栈较高层生成并存储在主机内存中的数据报，在链路层帧中封装该数据报，然后遵循链路接入协议将该帧传进通信链路中。在接收端，控制器接受了整个帧，抽取出网络层数据报。如果链路层执行差错检测，则需要发送控制器设置差错检测比特，在接收端进行差错检测。</p>
<h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><h4 id="偶校验方案"><a href="#偶校验方案" class="headerlink" title="偶校验方案"></a>偶校验方案</h4><p>发送方提包含一个附加的比特，使得这d+1个byte的1的总数是偶数</p>
<h4 id="奇校验方案"><a href="#奇校验方案" class="headerlink" title="奇校验方案"></a>奇校验方案</h4><p>发送方提包含一个附加的比特，使得这d+1个byte的1的总数是奇数、</p>
<p>二位校验</p>
<p>把原始的d个数据划分为i行j列的数据，然后进行检查纠错。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559649835665.png" alt="1559649835665"></p>
<p>接收方检测和纠正差错的能力被称为<strong>前向纠错</strong>。</p>
<h3 id="检验和方法"><a href="#检验和方法" class="headerlink" title="检验和方法"></a>检验和方法</h3><p>检验和</p>
<h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h3><p>链路层     CRC</p>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul>
<li>点对点链路：由链路一段的单个发送方和链路另一段的单个接收方组成。</li>
<li>广播链路：能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。</li>
</ul>
<p>多个节点同时发送 发生碰撞</p>
<p>人类的协议集</p>
<ul>
<li>给每个人一个讲话的机会</li>
<li>该你讲话的时候你才说话</li>
<li>不要一个人独占整个谈话</li>
<li>如果有问题请举手</li>
<li>当有人讲话时不要打断</li>
<li>当其他人讲话时不要睡觉</li>
</ul>
<p>多路访问协议用于规范主机在共享的广播信道上的传输行为。</p>
<p><img src="C:%5CUsers%5C11813%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1559651243274.png" alt="1559651243274"></p>
<h3 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h3><ul>
<li>时分多路复用（TDM）<ul>
<li>优点：消除了碰撞且非常公平，每个节点在每个帧时间内得到了专用的传输速率（R/N）</li>
<li>缺点：限制了平均速率，浪费了空闲时间</li>
</ul>
</li>
<li>频分多路复用（FDM）<ul>
<li>优点：消除了碰撞且非常公平，每个节点得到了专用的传输速率（R/N）</li>
<li>缺点：限制了平均速率，浪费了空闲时间</li>
</ul>
</li>
<li>码分多址（CDMA）:对每个节点分配一种不同的编码。然后每个节点用它唯一的编码来对他发送的数据进行编码，如果设计合理的话，不同的节点能够同时传输，并且能够被正确接收。</li>
</ul>
<h3 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h3><p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     、</p>
<h3 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h3><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/19/hello-world/" rel="prev" title="Hello World">
                Hello World <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.JPG" alt="zhuzhu">
            
              <p class="site-author-name" itemprop="name">zhuzhu</p>
              <p class="site-description motion-element" itemprop="description">街道口螺丝钉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zjy5755202" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#计算机网络复习总结"><span class="nav-number">1.</span> <span class="nav-text">计算机网络复习总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-计算机网络和因特网"><span class="nav-number">2.</span> <span class="nav-text">第一章 计算机网络和因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#因特网"><span class="nav-number">2.1.</span> <span class="nav-text">因特网</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组成"><span class="nav-number">2.1.1.</span> <span class="nav-text">组成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络边缘"><span class="nav-number">2.2.</span> <span class="nav-text">网络边缘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络核心"><span class="nav-number">2.3.</span> <span class="nav-text">网络核心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换"><span class="nav-number">2.3.1.</span> <span class="nav-text">分组交换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#存储转发传输"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">存储转发传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排队时延和分组丢失"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">排队时延和分组丢失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转发表和路由协议"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">转发表和路由协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电路交换"><span class="nav-number">2.3.2.</span> <span class="nav-text">电路交换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#电路交换网络中的复用"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">电路交换网络中的复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组交换和电路交换的对比"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">分组交换和电路交换的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#网络中的网络"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">网络中的网络</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分组交换网中的时延、丢包和吞吐量"><span class="nav-number">2.4.</span> <span class="nav-text">分组交换网中的时延、丢包和吞吐量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#时延"><span class="nav-number">2.4.1.</span> <span class="nav-text">时延</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量强度"><span class="nav-number">2.4.2.</span> <span class="nav-text">流量强度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#吞吐量"><span class="nav-number">2.4.3.</span> <span class="nav-text">吞吐量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议分层及其服务模型"><span class="nav-number">2.5.</span> <span class="nav-text">协议分层及其服务模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#五层协议栈"><span class="nav-number">2.5.1.</span> <span class="nav-text">五层协议栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI七层协议栈"><span class="nav-number">2.5.2.</span> <span class="nav-text">OSI七层协议栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装"><span class="nav-number">2.5.3.</span> <span class="nav-text">封装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向攻击的网络"><span class="nav-number">2.6.</span> <span class="nav-text">面向攻击的网络</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-应用层"><span class="nav-number">3.</span> <span class="nav-text">第二章 应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#应用程序体系结构"><span class="nav-number">3.1.</span> <span class="nav-text">应用程序体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程通信"><span class="nav-number">3.2.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#客户和服务器进程"><span class="nav-number">3.2.1.</span> <span class="nav-text">客户和服务器进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与计算机网络之间的接口"><span class="nav-number">3.2.2.</span> <span class="nav-text">进程与计算机网络之间的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程寻址"><span class="nav-number">3.2.3.</span> <span class="nav-text">进程寻址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">3.3.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#工作原理简介"><span class="nav-number">3.3.1.</span> <span class="nav-text">工作原理简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非持续链接和持续链接"><span class="nav-number">3.3.2.</span> <span class="nav-text">非持续链接和持续链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求"><span class="nav-number">3.3.3.</span> <span class="nav-text">请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#请求报文结构"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">请求报文结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单示例"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">简单示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应"><span class="nav-number">3.3.4.</span> <span class="nav-text">响应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#响应报文结构"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">响应报文结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单示例-1"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#状态码"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">状态码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户和服务器的交互：Cookie"><span class="nav-number">3.3.5.</span> <span class="nav-text">用户和服务器的交互：Cookie</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#支撑原理"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">支撑原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">3.3.6.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#工作机理"><span class="nav-number">3.3.6.1.</span> <span class="nav-text">工作机理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#好处"><span class="nav-number">3.3.6.2.</span> <span class="nav-text">好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件GET方法"><span class="nav-number">3.3.7.</span> <span class="nav-text">条件GET方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#电子邮件"><span class="nav-number">3.4.</span> <span class="nav-text">电子邮件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组成部分"><span class="nav-number">3.4.1.</span> <span class="nav-text">组成部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMTP"><span class="nav-number">3.4.2.</span> <span class="nav-text">SMTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMTP基本操作示例"><span class="nav-number">3.4.3.</span> <span class="nav-text">SMTP基本操作示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值得注意的是"><span class="nav-number">3.4.4.</span> <span class="nav-text">值得注意的是</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMTP和HTTP的关系"><span class="nav-number">3.4.5.</span> <span class="nav-text">SMTP和HTTP的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POP3"><span class="nav-number">3.4.6.</span> <span class="nav-text">POP3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作流程"><span class="nav-number">3.4.7.</span> <span class="nav-text">工作流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS（底层使用UDP，运行在53端口）"><span class="nav-number">3.5.</span> <span class="nav-text">DNS（底层使用UDP，运行在53端口）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">3.5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用示例"><span class="nav-number">3.5.2.</span> <span class="nav-text">使用示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提供的重要服务"><span class="nav-number">3.5.3.</span> <span class="nav-text">提供的重要服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作机理-1"><span class="nav-number">3.5.4.</span> <span class="nav-text">工作机理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地服务器"><span class="nav-number">3.5.5.</span> <span class="nav-text">本地服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS记录"><span class="nav-number">3.5.6.</span> <span class="nav-text">DNS记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS报文"><span class="nav-number">3.5.7.</span> <span class="nav-text">DNS报文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#P2P"><span class="nav-number">3.6.</span> <span class="nav-text">P2P</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视频流和分发流"><span class="nav-number">3.7.</span> <span class="nav-text">视频流和分发流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#套接字编程"><span class="nav-number">3.8.</span> <span class="nav-text">套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介-1"><span class="nav-number">3.8.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP套接字编程"><span class="nav-number">3.8.2.</span> <span class="nav-text">UDP套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">3.8.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDPClient-py"><span class="nav-number">3.8.2.2.</span> <span class="nav-text">UDPClient.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDPServer-py"><span class="nav-number">3.8.2.3.</span> <span class="nav-text">UDPServer.py</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP套接字编程"><span class="nav-number">3.8.3.</span> <span class="nav-text">TCP套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介-2"><span class="nav-number">3.8.3.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCPClient-py"><span class="nav-number">3.8.3.2.</span> <span class="nav-text">TCPClient.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCPServer-py"><span class="nav-number">3.8.3.3.</span> <span class="nav-text">TCPServer.py</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-运输层"><span class="nav-number">4.</span> <span class="nav-text">第三章 运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多路复用和多路分解"><span class="nav-number">4.2.</span> <span class="nav-text">多路复用和多路分解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介-3"><span class="nav-number">4.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无连接的多路复用和多路分解（UDP）"><span class="nav-number">4.2.2.</span> <span class="nav-text">无连接的多路复用和多路分解（UDP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向连接的多路复用与多路分解（TCP）"><span class="nav-number">4.2.3.</span> <span class="nav-text">面向连接的多路复用与多路分解（TCP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web与TCP"><span class="nav-number">4.2.4.</span> <span class="nav-text">Web与TCP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP——不可靠、无连接"><span class="nav-number">4.3.</span> <span class="nav-text">UDP——不可靠、无连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用UDP的主要原因"><span class="nav-number">4.3.1.</span> <span class="nav-text">使用UDP的主要原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#报文格式"><span class="nav-number">4.3.2.</span> <span class="nav-text">报文格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检验和"><span class="nav-number">4.3.3.</span> <span class="nav-text">检验和</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可靠传输数据原理"><span class="nav-number">4.4.</span> <span class="nav-text">可靠传输数据原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Rdt1-0——经完全可靠信道的可靠数据传输"><span class="nav-number">4.4.1.</span> <span class="nav-text">Rdt1.0——经完全可靠信道的可靠数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本简介"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">版本简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送端"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">发送端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收端"><span class="nav-number">4.4.1.3.</span> <span class="nav-text">接收端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rdt2-0——具有比特差错信道的可靠数据传输"><span class="nav-number">4.4.2.</span> <span class="nav-text">Rdt2.0——具有比特差错信道的可靠数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本简介-1"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">版本简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送端-1"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">发送端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收端-1"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">接收端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rdt2-1"><span class="nav-number">4.4.3.</span> <span class="nav-text">Rdt2.1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本简介-2"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">版本简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送端-2"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">发送端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收端-2"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">接收端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例"><span class="nav-number">4.4.3.4.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null"><span class="nav-number">4.4.3.5.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rdt2-2"><span class="nav-number">4.4.4.</span> <span class="nav-text">Rdt2.2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本简介-3"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">版本简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送端-3"><span class="nav-number">4.4.4.2.</span> <span class="nav-text">发送端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收端-3"><span class="nav-number">4.4.4.3.</span> <span class="nav-text">接收端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rdt3-0——具有比特差错的丢包信道的可靠数据传输"><span class="nav-number">4.4.5.</span> <span class="nav-text">Rdt3.0——具有比特差错的丢包信道的可靠数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本简介-4"><span class="nav-number">4.4.5.1.</span> <span class="nav-text">版本简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发送端-4"><span class="nav-number">4.4.5.2.</span> <span class="nav-text">发送端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流水线可靠数据传输协议"><span class="nav-number">4.4.6.</span> <span class="nav-text">流水线可靠数据传输协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回退N步（GBN"><span class="nav-number">4.4.7.</span> <span class="nav-text">回退N步（GBN)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送方"><span class="nav-number">4.4.7.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收方"><span class="nav-number">4.4.7.2.</span> <span class="nav-text">接收方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择重传-SR"><span class="nav-number">4.4.8.</span> <span class="nav-text">选择重传  (SR)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送方-1"><span class="nav-number">4.4.8.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收方-1"><span class="nav-number">4.4.8.2.</span> <span class="nav-text">接收方</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP——可靠、面向连接"><span class="nav-number">4.5.</span> <span class="nav-text">TCP——可靠、面向连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#报文结构"><span class="nav-number">4.5.1.</span> <span class="nav-text">报文结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#往返时间的估计与超时"><span class="nav-number">4.5.2.</span> <span class="nav-text">往返时间的估计与超时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可靠数据传输"><span class="nav-number">4.5.3.</span> <span class="nav-text">可靠数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#超时间隔加倍"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">超时间隔加倍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速重传（162？？？）"><span class="nav-number">4.5.3.2.</span> <span class="nav-text">快速重传（162？？？）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#差错恢复机制（GBN和SR的结合？？？）"><span class="nav-number">4.5.3.3.</span> <span class="nav-text">差错恢复机制（GBN和SR的结合？？？）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量控制"><span class="nav-number">4.5.4.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接管理"><span class="nav-number">4.5.5.</span> <span class="nav-text">连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三次握手建立连接"><span class="nav-number">4.5.5.1.</span> <span class="nav-text">三次握手建立连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四次挥手断开连接"><span class="nav-number">4.5.5.2.</span> <span class="nav-text">四次挥手断开连接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#状态转换"><span class="nav-number">4.5.5.2.1.</span> <span class="nav-text">状态转换</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拥塞控制（？？？）"><span class="nav-number">4.6.</span> <span class="nav-text">拥塞控制（？？？）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原因"><span class="nav-number">4.6.1.</span> <span class="nav-text">原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代价"><span class="nav-number">4.6.2.</span> <span class="nav-text">代价</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">4.6.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#慢启动（slow-start-AIMD）"><span class="nav-number">4.6.3.1.</span> <span class="nav-text">慢启动（slow start   AIMD）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#指数增加"><span class="nav-number">4.6.3.1.1.</span> <span class="nav-text">指数增加</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加法增加"><span class="nav-number">4.6.3.1.2.</span> <span class="nav-text">加法增加</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#乘法减少"><span class="nav-number">4.6.3.1.3.</span> <span class="nav-text">乘法减少</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作过程"><span class="nav-number">4.6.3.2.</span> <span class="nav-text">工作过程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-网络层：数据平面"><span class="nav-number">5.</span> <span class="nav-text">第四章 网络层：数据平面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#网络层概述"><span class="nav-number">5.1.</span> <span class="nav-text">网络层概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由器工作原理"><span class="nav-number">5.2.</span> <span class="nav-text">路由器工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入端口"><span class="nav-number">5.2.1.</span> <span class="nav-text">输入端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换结构"><span class="nav-number">5.2.2.</span> <span class="nav-text">交换结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#经过内存交换"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">经过内存交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#经总线交换"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">经总线交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#经互联网网络交换"><span class="nav-number">5.2.2.3.</span> <span class="nav-text">经互联网网络交换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出端口"><span class="nav-number">5.2.3.</span> <span class="nav-text">输出端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排队"><span class="nav-number">5.2.4.</span> <span class="nav-text">排队</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#输入排队"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">输入排队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出排队"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">输出排队</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组调度"><span class="nav-number">5.2.5.</span> <span class="nav-text">分组调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络协议：IPv4、寻址、IPv6及其他"><span class="nav-number">5.3.</span> <span class="nav-text">网络协议：IPv4、寻址、IPv6及其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4"><span class="nav-number">5.3.1.</span> <span class="nav-text">IPv4</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据报格式"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">数据报格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">分片</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻址"><span class="nav-number">5.3.2.</span> <span class="nav-text">寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取IP地址"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">获取IP地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络地址转换（NAT）"><span class="nav-number">5.3.3.</span> <span class="nav-text">网络地址转换（NAT）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv6"><span class="nav-number">5.3.4.</span> <span class="nav-text">IPv6</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据报格式-1"><span class="nav-number">5.3.4.1.</span> <span class="nav-text">数据报格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPv4到IPv6的迁移"><span class="nav-number">5.3.4.2.</span> <span class="nav-text">IPv4到IPv6的迁移</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用转发和SDN（？？？231）"><span class="nav-number">5.4.</span> <span class="nav-text">通用转发和SDN（？？？231）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-网络层：控制平面"><span class="nav-number">6.</span> <span class="nav-text">第五章 网络层：控制平面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由选择算法"><span class="nav-number">6.2.</span> <span class="nav-text">路由选择算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#链路状态路由选择算法（LS）"><span class="nav-number">6.2.1.</span> <span class="nav-text">链路状态路由选择算法（LS）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#距离向量路由选择算法（DV）"><span class="nav-number">6.2.2.</span> <span class="nav-text">距离向量路由选择算法（DV）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSPF：因特网中自治系统内部的路由选择"><span class="nav-number">6.3.</span> <span class="nav-text">OSPF：因特网中自治系统内部的路由选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP-ISP之间的路由选择"><span class="nav-number">6.4.</span> <span class="nav-text">BGP :ISP之间的路由选择</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#热土豆路由选择"><span class="nav-number">6.4.1.</span> <span class="nav-text">热土豆路由选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由器选择算法"><span class="nav-number">6.4.2.</span> <span class="nav-text">路由器选择算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP任播"><span class="nav-number">6.4.3.</span> <span class="nav-text">IP任播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由选择策略"><span class="nav-number">6.4.4.</span> <span class="nav-text">路由选择策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDN控制平面"><span class="nav-number">6.5.</span> <span class="nav-text">SDN控制平面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP-：因特网控制报文协议"><span class="nav-number">6.6.</span> <span class="nav-text">ICMP ：因特网控制报文协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络管理和SNMP"><span class="nav-number">6.7.</span> <span class="nav-text">网络管理和SNMP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-链路层和局域网"><span class="nav-number">7.</span> <span class="nav-text">第六章 链路层和局域网</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#链路层概述"><span class="nav-number">7.1.</span> <span class="nav-text">链路层概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#差错检测和纠正技术"><span class="nav-number">7.2.</span> <span class="nav-text">差错检测和纠正技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#奇偶校验"><span class="nav-number">7.2.1.</span> <span class="nav-text">奇偶校验</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#偶校验方案"><span class="nav-number">7.2.1.1.</span> <span class="nav-text">偶校验方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#奇校验方案"><span class="nav-number">7.2.1.2.</span> <span class="nav-text">奇校验方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检验和方法"><span class="nav-number">7.2.2.</span> <span class="nav-text">检验和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环冗余检测"><span class="nav-number">7.2.3.</span> <span class="nav-text">循环冗余检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多路访问链路和协议"><span class="nav-number">7.3.</span> <span class="nav-text">多路访问链路和协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信道划分协议"><span class="nav-number">7.3.1.</span> <span class="nav-text">信道划分协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#随机接入协议"><span class="nav-number">7.3.2.</span> <span class="nav-text">随机接入协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轮流协议"><span class="nav-number">7.3.3.</span> <span class="nav-text">轮流协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#交换局域网"><span class="nav-number">7.4.</span> <span class="nav-text">交换局域网</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhuzhu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
